# 解决方案
- 问题1:new关键字将service层的实现类TransferServiceImpl和Dao层的具体实现类JdbcAccountDaoImpl耦合在了一起，
当需要切换切换Dao层实现类的时候，必须的修改很多使用到的业务层的代码，不符合面向接口开发最优原则

- 思考:
(1) new关键字实例化对象，除了new以外还有什么技术可以实例化对象呢(当然是反射喽)Class.forName("全限定类名");
com.wy.solution.dao.impl.JdbcAccountDaoImpl 可以把全限定类名配置在xml文件中
(2)通过反射可以动态的替换掉使用new对象，但是还有一个问题并没有解决呢，通过反射创建对象后，因为forName是全限定类名，这个也需要
来进行更改，如果有业务需求替换的话，以及业务中如何来使用这个对象呢？所以问题就来了，这也是个通过反射实现之后如何使用的问题，以至于
业务代码和实际对象进行解耦。

工厂模式就起到了一个非常好的作用，在业务类中，从工厂中来拿要用到的对象，工厂负责具体的创建对象的工作。这样就解决了如何在业务类中使用的问题，
业务类也不需要关心底层对象是否有改变，我只拿自己所需要的就可以了，无论dao层有任何改变，你是不需要管的，这样的话，如果有变更，只需要修改一个地方
就可以了，那就是xml文件配置，把全限定类名修改掉，就可以实现业务需要的变更，影响范围较小，稳定性更容易把控。

具体工厂怎么通过反射来生产对象呢?
1. 读取解析xml文件，然后通过反射技术来实例化对象即可，然后提供一个外部需要使用的获取对象实例的方法。

更进一步的来讲，代码中能否只声明所使用的接口类型，不需要new也不需要出现工厂类的字眼呢？这个是否能解决呢，这样确确实实就起到了最真实的解耦的目的，
只要把我需要的实例组合进来即可。


-问题2
service层没有添加事务控制，怎么办？

思考
(1)没有事务就添加事务控制，手动控制JDBC的Connection事务，但是要注意将Connection和当前线程绑定(即保证一个线程只有一个Connection，这样
操作才针对的是同一个Connection，进而控制的是同一个事务)。

数据库事务归根结低是connection的事务
commit  rollback

如果两次update操作，使用两个数据库连接的话，这样的话，肯定是不属于一个事务控制了

那又延伸出来一个问题？那就是如何保证两次update操作使用同一个连接呢？
答案:
(因为两次update属于同一个线程内的执行调用，我们可以给当前
线程绑定一个Connection，和当前线程有关系的数据库操作都去使用这个Connection，从当前线程去拿)

其实综上所述的话，其实也就是耦合和事务如何解决的问题

1.解耦
2.工厂模式，通过反射创建对象
3.事务控制，要保证当前线程所有的数据库操作是一个connection，不然的话，不能进行事务控制。
